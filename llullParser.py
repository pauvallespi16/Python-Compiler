# Generated from llull.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3&")
        buf.write("\u00db\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\3\2\7\2,\n\2\f\2\16\2/\13\2\3\2\6")
        buf.write("\2\62\n\2\r\2\16\2\63\3\2\7\2\67\n\2\f\2\16\2:\13\2\7")
        buf.write("\2<\n\2\f\2\16\2?\13\2\3\2\3\2\3\3\7\3D\n\3\f\3\16\3G")
        buf.write("\13\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4")
        buf.write("T\n\4\3\5\3\5\3\5\3\5\3\6\3\6\3\6\5\6]\n\6\3\6\3\6\3\7")
        buf.write("\3\7\3\7\7\7d\n\7\f\7\16\7g\13\7\3\b\3\b\3\b\3\b\3\t\3")
        buf.write("\t\3\t\3\t\3\t\7\tr\n\t\f\t\16\tu\13\t\3\t\3\t\5\ty\n")
        buf.write("\t\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3")
        buf.write("\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\20\3\20\3\20")
        buf.write("\3\20\3\20\7\20\u009f\n\20\f\20\16\20\u00a2\13\20\3\20")
        buf.write("\3\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\22\3\22\3\22")
        buf.write("\3\22\3\22\3\22\3\22\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\24\3\24\3\24\3\24\3\24\5\24\u00c2\n\24\3")
        buf.write("\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\7\24\u00cd")
        buf.write("\n\24\f\24\16\24\u00d0\13\24\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\3\25\5\25\u00d9\n\25\3\25\2\3&\26\2\4\6\b\n\f\16")
        buf.write("\20\22\24\26\30\32\34\36 \"$&(\2\4\4\2\n\13\r\r\4\2\b")
        buf.write("\t\16\23\2\u00e2\2=\3\2\2\2\4E\3\2\2\2\6S\3\2\2\2\bU\3")
        buf.write("\2\2\2\nY\3\2\2\2\f`\3\2\2\2\16h\3\2\2\2\20l\3\2\2\2\22")
        buf.write("z\3\2\2\2\24}\3\2\2\2\26\u0081\3\2\2\2\30\u0086\3\2\2")
        buf.write("\2\32\u008a\3\2\2\2\34\u0094\3\2\2\2\36\u0099\3\2\2\2")
        buf.write(" \u00a5\3\2\2\2\"\u00ac\3\2\2\2$\u00b3\3\2\2\2&\u00c1")
        buf.write("\3\2\2\2(\u00d8\3\2\2\2*,\5\16\b\2+*\3\2\2\2,/\3\2\2\2")
        buf.write("-+\3\2\2\2-.\3\2\2\2.\61\3\2\2\2/-\3\2\2\2\60\62\5\b\5")
        buf.write("\2\61\60\3\2\2\2\62\63\3\2\2\2\63\61\3\2\2\2\63\64\3\2")
        buf.write("\2\2\648\3\2\2\2\65\67\5\16\b\2\66\65\3\2\2\2\67:\3\2")
        buf.write("\2\28\66\3\2\2\289\3\2\2\29<\3\2\2\2:8\3\2\2\2;-\3\2\2")
        buf.write("\2<?\3\2\2\2=;\3\2\2\2=>\3\2\2\2>@\3\2\2\2?=\3\2\2\2@")
        buf.write("A\7\2\2\3A\3\3\2\2\2BD\5\6\4\2CB\3\2\2\2DG\3\2\2\2EC\3")
        buf.write("\2\2\2EF\3\2\2\2F\5\3\2\2\2GE\3\2\2\2HT\5\16\b\2IT\5 ")
        buf.write("\21\2JT\5\"\22\2KT\5$\23\2LT\5\20\t\2MT\5\30\r\2NT\5\26")
        buf.write("\f\2OT\5\32\16\2PT\5\n\6\2QT\5\34\17\2RT\5\36\20\2SH\3")
        buf.write("\2\2\2SI\3\2\2\2SJ\3\2\2\2SK\3\2\2\2SL\3\2\2\2SM\3\2\2")
        buf.write("\2SN\3\2\2\2SO\3\2\2\2SP\3\2\2\2SQ\3\2\2\2SR\3\2\2\2T")
        buf.write("\7\3\2\2\2UV\7\33\2\2VW\5\n\6\2WX\5\24\13\2X\t\3\2\2\2")
        buf.write("YZ\7$\2\2Z\\\7\4\2\2[]\5\f\7\2\\[\3\2\2\2\\]\3\2\2\2]")
        buf.write("^\3\2\2\2^_\7\5\2\2_\13\3\2\2\2`e\5&\24\2ab\7\37\2\2b")
        buf.write("d\5&\24\2ca\3\2\2\2dg\3\2\2\2ec\3\2\2\2ef\3\2\2\2f\r\3")
        buf.write("\2\2\2ge\3\2\2\2hi\7$\2\2ij\7!\2\2jk\5&\24\2k\17\3\2\2")
        buf.write("\2lm\7\26\2\2ms\5\22\n\2no\7\32\2\2op\7\26\2\2pr\5\22")
        buf.write("\n\2qn\3\2\2\2ru\3\2\2\2sq\3\2\2\2st\3\2\2\2tx\3\2\2\2")
        buf.write("us\3\2\2\2vw\7\32\2\2wy\5\24\13\2xv\3\2\2\2xy\3\2\2\2")
        buf.write("y\21\3\2\2\2z{\5&\24\2{|\5\24\13\2|\23\3\2\2\2}~\7\6\2")
        buf.write("\2~\177\5\4\3\2\177\u0080\7\7\2\2\u0080\25\3\2\2\2\u0081")
        buf.write("\u0082\7\30\2\2\u0082\u0083\5\24\13\2\u0083\u0084\7\27")
        buf.write("\2\2\u0084\u0085\5&\24\2\u0085\27\3\2\2\2\u0086\u0087")
        buf.write("\7\27\2\2\u0087\u0088\5&\24\2\u0088\u0089\5\24\13\2\u0089")
        buf.write("\31\3\2\2\2\u008a\u008b\7\31\2\2\u008b\u008c\7\4\2\2\u008c")
        buf.write("\u008d\5\16\b\2\u008d\u008e\7 \2\2\u008e\u008f\5&\24\2")
        buf.write("\u008f\u0090\7 \2\2\u0090\u0091\5\16\b\2\u0091\u0092\7")
        buf.write("\5\2\2\u0092\u0093\5\24\13\2\u0093\33\3\2\2\2\u0094\u0095")
        buf.write("\7\24\2\2\u0095\u0096\7\4\2\2\u0096\u0097\7$\2\2\u0097")
        buf.write("\u0098\7\5\2\2\u0098\35\3\2\2\2\u0099\u009a\7\25\2\2\u009a")
        buf.write("\u009b\7\4\2\2\u009b\u00a0\5&\24\2\u009c\u009d\7\37\2")
        buf.write("\2\u009d\u009f\5&\24\2\u009e\u009c\3\2\2\2\u009f\u00a2")
        buf.write("\3\2\2\2\u00a0\u009e\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1")
        buf.write("\u00a3\3\2\2\2\u00a2\u00a0\3\2\2\2\u00a3\u00a4\7\5\2\2")
        buf.write("\u00a4\37\3\2\2\2\u00a5\u00a6\7\34\2\2\u00a6\u00a7\7\4")
        buf.write("\2\2\u00a7\u00a8\7$\2\2\u00a8\u00a9\7\37\2\2\u00a9\u00aa")
        buf.write("\5&\24\2\u00aa\u00ab\7\5\2\2\u00ab!\3\2\2\2\u00ac\u00ad")
        buf.write("\7\35\2\2\u00ad\u00ae\7\4\2\2\u00ae\u00af\7$\2\2\u00af")
        buf.write("\u00b0\7\37\2\2\u00b0\u00b1\5&\24\2\u00b1\u00b2\7\5\2")
        buf.write("\2\u00b2#\3\2\2\2\u00b3\u00b4\7\36\2\2\u00b4\u00b5\7\4")
        buf.write("\2\2\u00b5\u00b6\7$\2\2\u00b6\u00b7\7\37\2\2\u00b7\u00b8")
        buf.write("\5&\24\2\u00b8\u00b9\7\37\2\2\u00b9\u00ba\5(\25\2\u00ba")
        buf.write("\u00bb\7\5\2\2\u00bb%\3\2\2\2\u00bc\u00bd\b\24\1\2\u00bd")
        buf.write("\u00c2\5\"\22\2\u00be\u00bf\7\t\2\2\u00bf\u00c2\5&\24")
        buf.write("\6\u00c0\u00c2\5(\25\2\u00c1\u00bc\3\2\2\2\u00c1\u00be")
        buf.write("\3\2\2\2\u00c1\u00c0\3\2\2\2\u00c2\u00ce\3\2\2\2\u00c3")
        buf.write("\u00c4\f\7\2\2\u00c4\u00c5\7\f\2\2\u00c5\u00cd\5&\24\7")
        buf.write("\u00c6\u00c7\f\5\2\2\u00c7\u00c8\t\2\2\2\u00c8\u00cd\5")
        buf.write("&\24\6\u00c9\u00ca\f\4\2\2\u00ca\u00cb\t\3\2\2\u00cb\u00cd")
        buf.write("\5&\24\5\u00cc\u00c3\3\2\2\2\u00cc\u00c6\3\2\2\2\u00cc")
        buf.write("\u00c9\3\2\2\2\u00cd\u00d0\3\2\2\2\u00ce\u00cc\3\2\2\2")
        buf.write("\u00ce\u00cf\3\2\2\2\u00cf\'\3\2\2\2\u00d0\u00ce\3\2\2")
        buf.write("\2\u00d1\u00d2\7\4\2\2\u00d2\u00d3\5&\24\2\u00d3\u00d4")
        buf.write("\7\5\2\2\u00d4\u00d9\3\2\2\2\u00d5\u00d9\7\3\2\2\u00d6")
        buf.write("\u00d9\7#\2\2\u00d7\u00d9\7$\2\2\u00d8\u00d1\3\2\2\2\u00d8")
        buf.write("\u00d5\3\2\2\2\u00d8\u00d6\3\2\2\2\u00d8\u00d7\3\2\2\2")
        buf.write("\u00d9)\3\2\2\2\21-\638=ES\\esx\u00a0\u00c1\u00cc\u00ce")
        buf.write("\u00d8")
        return buf.getvalue()


class llullParser ( Parser ):

    grammarFileName = "llull.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'('", "')'", "'{'", "'}'", 
                     "'+'", "'-'", "'*'", "'/'", "'^'", "'%'", "'>'", "'<'", 
                     "'>='", "'<='", "'=='", "'<>'", "'read'", "'write'", 
                     "'if'", "'while'", "'do'", "'for'", "'else'", "'void'", 
                     "'array'", "'get'", "'set'", "','", "';'", "'='", "'0'" ]

    symbolicNames = [ "<INVALID>", "NUM", "PARL", "PARR", "BRACEL", "BRACER", 
                      "ADD", "SUB", "MULT", "DIV", "POW", "MOD", "GT", "LT", 
                      "GT_EQ", "LT_EQ", "EQUAL", "NOT_EQ", "READ", "WRITE", 
                      "IF", "WHILE", "DO", "FOR", "ELSE", "VOID", "ARRAY", 
                      "GET", "SET", "COMMA", "SCOL", "ASSIG", "ZERO", "STRING", 
                      "ID", "COMMENT", "WS" ]

    RULE_root = 0
    RULE_block = 1
    RULE_stat = 2
    RULE_function = 3
    RULE_function_stat = 4
    RULE_arguments = 5
    RULE_assignment = 6
    RULE_if_stat = 7
    RULE_condition_block = 8
    RULE_stat_block = 9
    RULE_do_while_stat = 10
    RULE_while_stat = 11
    RULE_for_stat = 12
    RULE_read = 13
    RULE_write = 14
    RULE_array_stat = 15
    RULE_getter_stat = 16
    RULE_setter_stat = 17
    RULE_expr = 18
    RULE_atom = 19

    ruleNames =  [ "root", "block", "stat", "function", "function_stat", 
                   "arguments", "assignment", "if_stat", "condition_block", 
                   "stat_block", "do_while_stat", "while_stat", "for_stat", 
                   "read", "write", "array_stat", "getter_stat", "setter_stat", 
                   "expr", "atom" ]

    EOF = Token.EOF
    NUM=1
    PARL=2
    PARR=3
    BRACEL=4
    BRACER=5
    ADD=6
    SUB=7
    MULT=8
    DIV=9
    POW=10
    MOD=11
    GT=12
    LT=13
    GT_EQ=14
    LT_EQ=15
    EQUAL=16
    NOT_EQ=17
    READ=18
    WRITE=19
    IF=20
    WHILE=21
    DO=22
    FOR=23
    ELSE=24
    VOID=25
    ARRAY=26
    GET=27
    SET=28
    COMMA=29
    SCOL=30
    ASSIG=31
    ZERO=32
    STRING=33
    ID=34
    COMMENT=35
    WS=36

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RootContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(llullParser.EOF, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(llullParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(llullParser.AssignmentContext,i)


        def function(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(llullParser.FunctionContext)
            else:
                return self.getTypedRuleContext(llullParser.FunctionContext,i)


        def getRuleIndex(self):
            return llullParser.RULE_root

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoot" ):
                return visitor.visitRoot(self)
            else:
                return visitor.visitChildren(self)




    def root(self):

        localctx = llullParser.RootContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_root)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 59
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==llullParser.VOID or _la==llullParser.ID:
                self.state = 43
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==llullParser.ID:
                    self.state = 40
                    self.assignment()
                    self.state = 45
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 47 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 46
                        self.function()

                    else:
                        raise NoViableAltException(self)
                    self.state = 49 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

                self.state = 54
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 51
                        self.assignment() 
                    self.state = 56
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

                self.state = 61
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 62
            self.match(llullParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(llullParser.StatContext)
            else:
                return self.getTypedRuleContext(llullParser.StatContext,i)


        def getRuleIndex(self):
            return llullParser.RULE_block

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = llullParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << llullParser.READ) | (1 << llullParser.WRITE) | (1 << llullParser.IF) | (1 << llullParser.WHILE) | (1 << llullParser.DO) | (1 << llullParser.FOR) | (1 << llullParser.ARRAY) | (1 << llullParser.GET) | (1 << llullParser.SET) | (1 << llullParser.ID))) != 0):
                self.state = 64
                self.stat()
                self.state = 69
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(llullParser.AssignmentContext,0)


        def array_stat(self):
            return self.getTypedRuleContext(llullParser.Array_statContext,0)


        def getter_stat(self):
            return self.getTypedRuleContext(llullParser.Getter_statContext,0)


        def setter_stat(self):
            return self.getTypedRuleContext(llullParser.Setter_statContext,0)


        def if_stat(self):
            return self.getTypedRuleContext(llullParser.If_statContext,0)


        def while_stat(self):
            return self.getTypedRuleContext(llullParser.While_statContext,0)


        def do_while_stat(self):
            return self.getTypedRuleContext(llullParser.Do_while_statContext,0)


        def for_stat(self):
            return self.getTypedRuleContext(llullParser.For_statContext,0)


        def function_stat(self):
            return self.getTypedRuleContext(llullParser.Function_statContext,0)


        def read(self):
            return self.getTypedRuleContext(llullParser.ReadContext,0)


        def write(self):
            return self.getTypedRuleContext(llullParser.WriteContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat" ):
                return visitor.visitStat(self)
            else:
                return visitor.visitChildren(self)




    def stat(self):

        localctx = llullParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_stat)
        try:
            self.state = 81
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 70
                self.assignment()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 71
                self.array_stat()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 72
                self.getter_stat()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 73
                self.setter_stat()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 74
                self.if_stat()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 75
                self.while_stat()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 76
                self.do_while_stat()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 77
                self.for_stat()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 78
                self.function_stat()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 79
                self.read()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 80
                self.write()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOID(self):
            return self.getToken(llullParser.VOID, 0)

        def function_stat(self):
            return self.getTypedRuleContext(llullParser.Function_statContext,0)


        def stat_block(self):
            return self.getTypedRuleContext(llullParser.Stat_blockContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_function

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction" ):
                return visitor.visitFunction(self)
            else:
                return visitor.visitChildren(self)




    def function(self):

        localctx = llullParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_function)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.match(llullParser.VOID)
            self.state = 84
            self.function_stat()
            self.state = 85
            self.stat_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(llullParser.ID, 0)

        def PARL(self):
            return self.getToken(llullParser.PARL, 0)

        def PARR(self):
            return self.getToken(llullParser.PARR, 0)

        def arguments(self):
            return self.getTypedRuleContext(llullParser.ArgumentsContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_function_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_stat" ):
                return visitor.visitFunction_stat(self)
            else:
                return visitor.visitChildren(self)




    def function_stat(self):

        localctx = llullParser.Function_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_function_stat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            self.match(llullParser.ID)
            self.state = 88
            self.match(llullParser.PARL)
            self.state = 90
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << llullParser.NUM) | (1 << llullParser.PARL) | (1 << llullParser.SUB) | (1 << llullParser.GET) | (1 << llullParser.STRING) | (1 << llullParser.ID))) != 0):
                self.state = 89
                self.arguments()


            self.state = 92
            self.match(llullParser.PARR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(llullParser.ExprContext)
            else:
                return self.getTypedRuleContext(llullParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(llullParser.COMMA)
            else:
                return self.getToken(llullParser.COMMA, i)

        def getRuleIndex(self):
            return llullParser.RULE_arguments

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArguments" ):
                return visitor.visitArguments(self)
            else:
                return visitor.visitChildren(self)




    def arguments(self):

        localctx = llullParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.expr(0)
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==llullParser.COMMA:
                self.state = 95
                self.match(llullParser.COMMA)
                self.state = 96
                self.expr(0)
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(llullParser.ID, 0)

        def ASSIG(self):
            return self.getToken(llullParser.ASSIG, 0)

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_assignment

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = llullParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(llullParser.ID)
            self.state = 103
            self.match(llullParser.ASSIG)
            self.state = 104
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self, i:int=None):
            if i is None:
                return self.getTokens(llullParser.IF)
            else:
                return self.getToken(llullParser.IF, i)

        def condition_block(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(llullParser.Condition_blockContext)
            else:
                return self.getTypedRuleContext(llullParser.Condition_blockContext,i)


        def ELSE(self, i:int=None):
            if i is None:
                return self.getTokens(llullParser.ELSE)
            else:
                return self.getToken(llullParser.ELSE, i)

        def stat_block(self):
            return self.getTypedRuleContext(llullParser.Stat_blockContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_if_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf_stat" ):
                return visitor.visitIf_stat(self)
            else:
                return visitor.visitChildren(self)




    def if_stat(self):

        localctx = llullParser.If_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_if_stat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.match(llullParser.IF)
            self.state = 107
            self.condition_block()
            self.state = 113
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 108
                    self.match(llullParser.ELSE)
                    self.state = 109
                    self.match(llullParser.IF)
                    self.state = 110
                    self.condition_block() 
                self.state = 115
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

            self.state = 118
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==llullParser.ELSE:
                self.state = 116
                self.match(llullParser.ELSE)
                self.state = 117
                self.stat_block()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Condition_blockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def stat_block(self):
            return self.getTypedRuleContext(llullParser.Stat_blockContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_condition_block

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition_block" ):
                return visitor.visitCondition_block(self)
            else:
                return visitor.visitChildren(self)




    def condition_block(self):

        localctx = llullParser.Condition_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_condition_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.expr(0)
            self.state = 121
            self.stat_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stat_blockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BRACEL(self):
            return self.getToken(llullParser.BRACEL, 0)

        def block(self):
            return self.getTypedRuleContext(llullParser.BlockContext,0)


        def BRACER(self):
            return self.getToken(llullParser.BRACER, 0)

        def getRuleIndex(self):
            return llullParser.RULE_stat_block

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_block" ):
                return visitor.visitStat_block(self)
            else:
                return visitor.visitChildren(self)




    def stat_block(self):

        localctx = llullParser.Stat_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_stat_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(llullParser.BRACEL)
            self.state = 124
            self.block()
            self.state = 125
            self.match(llullParser.BRACER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Do_while_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO(self):
            return self.getToken(llullParser.DO, 0)

        def stat_block(self):
            return self.getTypedRuleContext(llullParser.Stat_blockContext,0)


        def WHILE(self):
            return self.getToken(llullParser.WHILE, 0)

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_do_while_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDo_while_stat" ):
                return visitor.visitDo_while_stat(self)
            else:
                return visitor.visitChildren(self)




    def do_while_stat(self):

        localctx = llullParser.Do_while_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_do_while_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.match(llullParser.DO)
            self.state = 128
            self.stat_block()
            self.state = 129
            self.match(llullParser.WHILE)
            self.state = 130
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class While_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(llullParser.WHILE, 0)

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def stat_block(self):
            return self.getTypedRuleContext(llullParser.Stat_blockContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_while_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhile_stat" ):
                return visitor.visitWhile_stat(self)
            else:
                return visitor.visitChildren(self)




    def while_stat(self):

        localctx = llullParser.While_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_while_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(llullParser.WHILE)
            self.state = 133
            self.expr(0)
            self.state = 134
            self.stat_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(llullParser.FOR, 0)

        def PARL(self):
            return self.getToken(llullParser.PARL, 0)

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(llullParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(llullParser.AssignmentContext,i)


        def SCOL(self, i:int=None):
            if i is None:
                return self.getTokens(llullParser.SCOL)
            else:
                return self.getToken(llullParser.SCOL, i)

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def PARR(self):
            return self.getToken(llullParser.PARR, 0)

        def stat_block(self):
            return self.getTypedRuleContext(llullParser.Stat_blockContext,0)


        def getRuleIndex(self):
            return llullParser.RULE_for_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_stat" ):
                return visitor.visitFor_stat(self)
            else:
                return visitor.visitChildren(self)




    def for_stat(self):

        localctx = llullParser.For_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_for_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            self.match(llullParser.FOR)
            self.state = 137
            self.match(llullParser.PARL)
            self.state = 138
            self.assignment()
            self.state = 139
            self.match(llullParser.SCOL)
            self.state = 140
            self.expr(0)
            self.state = 141
            self.match(llullParser.SCOL)
            self.state = 142
            self.assignment()
            self.state = 143
            self.match(llullParser.PARR)
            self.state = 144
            self.stat_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READ(self):
            return self.getToken(llullParser.READ, 0)

        def PARL(self):
            return self.getToken(llullParser.PARL, 0)

        def ID(self):
            return self.getToken(llullParser.ID, 0)

        def PARR(self):
            return self.getToken(llullParser.PARR, 0)

        def getRuleIndex(self):
            return llullParser.RULE_read

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRead" ):
                return visitor.visitRead(self)
            else:
                return visitor.visitChildren(self)




    def read(self):

        localctx = llullParser.ReadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_read)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.match(llullParser.READ)
            self.state = 147
            self.match(llullParser.PARL)
            self.state = 148
            self.match(llullParser.ID)
            self.state = 149
            self.match(llullParser.PARR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WriteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WRITE(self):
            return self.getToken(llullParser.WRITE, 0)

        def PARL(self):
            return self.getToken(llullParser.PARL, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(llullParser.ExprContext)
            else:
                return self.getTypedRuleContext(llullParser.ExprContext,i)


        def PARR(self):
            return self.getToken(llullParser.PARR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(llullParser.COMMA)
            else:
                return self.getToken(llullParser.COMMA, i)

        def getRuleIndex(self):
            return llullParser.RULE_write

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWrite" ):
                return visitor.visitWrite(self)
            else:
                return visitor.visitChildren(self)




    def write(self):

        localctx = llullParser.WriteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_write)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(llullParser.WRITE)
            self.state = 152
            self.match(llullParser.PARL)
            self.state = 153
            self.expr(0)
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==llullParser.COMMA:
                self.state = 154
                self.match(llullParser.COMMA)
                self.state = 155
                self.expr(0)
                self.state = 160
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 161
            self.match(llullParser.PARR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(llullParser.ARRAY, 0)

        def PARL(self):
            return self.getToken(llullParser.PARL, 0)

        def ID(self):
            return self.getToken(llullParser.ID, 0)

        def COMMA(self):
            return self.getToken(llullParser.COMMA, 0)

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def PARR(self):
            return self.getToken(llullParser.PARR, 0)

        def getRuleIndex(self):
            return llullParser.RULE_array_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_stat" ):
                return visitor.visitArray_stat(self)
            else:
                return visitor.visitChildren(self)




    def array_stat(self):

        localctx = llullParser.Array_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_array_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(llullParser.ARRAY)
            self.state = 164
            self.match(llullParser.PARL)
            self.state = 165
            self.match(llullParser.ID)
            self.state = 166
            self.match(llullParser.COMMA)
            self.state = 167
            self.expr(0)
            self.state = 168
            self.match(llullParser.PARR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Getter_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(llullParser.GET, 0)

        def PARL(self):
            return self.getToken(llullParser.PARL, 0)

        def ID(self):
            return self.getToken(llullParser.ID, 0)

        def COMMA(self):
            return self.getToken(llullParser.COMMA, 0)

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def PARR(self):
            return self.getToken(llullParser.PARR, 0)

        def getRuleIndex(self):
            return llullParser.RULE_getter_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetter_stat" ):
                return visitor.visitGetter_stat(self)
            else:
                return visitor.visitChildren(self)




    def getter_stat(self):

        localctx = llullParser.Getter_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_getter_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.match(llullParser.GET)
            self.state = 171
            self.match(llullParser.PARL)
            self.state = 172
            self.match(llullParser.ID)
            self.state = 173
            self.match(llullParser.COMMA)
            self.state = 174
            self.expr(0)
            self.state = 175
            self.match(llullParser.PARR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Setter_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(llullParser.SET, 0)

        def PARL(self):
            return self.getToken(llullParser.PARL, 0)

        def ID(self):
            return self.getToken(llullParser.ID, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(llullParser.COMMA)
            else:
                return self.getToken(llullParser.COMMA, i)

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def atom(self):
            return self.getTypedRuleContext(llullParser.AtomContext,0)


        def PARR(self):
            return self.getToken(llullParser.PARR, 0)

        def getRuleIndex(self):
            return llullParser.RULE_setter_stat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetter_stat" ):
                return visitor.visitSetter_stat(self)
            else:
                return visitor.visitChildren(self)




    def setter_stat(self):

        localctx = llullParser.Setter_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_setter_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(llullParser.SET)
            self.state = 178
            self.match(llullParser.PARL)
            self.state = 179
            self.match(llullParser.ID)
            self.state = 180
            self.match(llullParser.COMMA)
            self.state = 181
            self.expr(0)
            self.state = 182
            self.match(llullParser.COMMA)
            self.state = 183
            self.atom()
            self.state = 184
            self.match(llullParser.PARR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getter_stat(self):
            return self.getTypedRuleContext(llullParser.Getter_statContext,0)


        def SUB(self):
            return self.getToken(llullParser.SUB, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(llullParser.ExprContext)
            else:
                return self.getTypedRuleContext(llullParser.ExprContext,i)


        def atom(self):
            return self.getTypedRuleContext(llullParser.AtomContext,0)


        def POW(self):
            return self.getToken(llullParser.POW, 0)

        def MULT(self):
            return self.getToken(llullParser.MULT, 0)

        def DIV(self):
            return self.getToken(llullParser.DIV, 0)

        def MOD(self):
            return self.getToken(llullParser.MOD, 0)

        def ADD(self):
            return self.getToken(llullParser.ADD, 0)

        def GT(self):
            return self.getToken(llullParser.GT, 0)

        def LT(self):
            return self.getToken(llullParser.LT, 0)

        def GT_EQ(self):
            return self.getToken(llullParser.GT_EQ, 0)

        def LT_EQ(self):
            return self.getToken(llullParser.LT_EQ, 0)

        def EQUAL(self):
            return self.getToken(llullParser.EQUAL, 0)

        def NOT_EQ(self):
            return self.getToken(llullParser.NOT_EQ, 0)

        def getRuleIndex(self):
            return llullParser.RULE_expr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = llullParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 36
        self.enterRecursionRule(localctx, 36, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [llullParser.GET]:
                self.state = 187
                self.getter_stat()
                pass
            elif token in [llullParser.SUB]:
                self.state = 188
                self.match(llullParser.SUB)
                self.state = 189
                self.expr(4)
                pass
            elif token in [llullParser.NUM, llullParser.PARL, llullParser.STRING, llullParser.ID]:
                self.state = 190
                self.atom()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 204
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 202
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                    if la_ == 1:
                        localctx = llullParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 193
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 194
                        self.match(llullParser.POW)
                        self.state = 195
                        self.expr(5)
                        pass

                    elif la_ == 2:
                        localctx = llullParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 196
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 197
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << llullParser.MULT) | (1 << llullParser.DIV) | (1 << llullParser.MOD))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 198
                        self.expr(4)
                        pass

                    elif la_ == 3:
                        localctx = llullParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 199
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 200
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << llullParser.ADD) | (1 << llullParser.SUB) | (1 << llullParser.GT) | (1 << llullParser.LT) | (1 << llullParser.GT_EQ) | (1 << llullParser.LT_EQ) | (1 << llullParser.EQUAL) | (1 << llullParser.NOT_EQ))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 201
                        self.expr(3)
                        pass

             
                self.state = 206
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARL(self):
            return self.getToken(llullParser.PARL, 0)

        def expr(self):
            return self.getTypedRuleContext(llullParser.ExprContext,0)


        def PARR(self):
            return self.getToken(llullParser.PARR, 0)

        def NUM(self):
            return self.getToken(llullParser.NUM, 0)

        def STRING(self):
            return self.getToken(llullParser.STRING, 0)

        def ID(self):
            return self.getToken(llullParser.ID, 0)

        def getRuleIndex(self):
            return llullParser.RULE_atom

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = llullParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_atom)
        try:
            self.state = 214
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [llullParser.PARL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 207
                self.match(llullParser.PARL)
                self.state = 208
                self.expr(0)
                self.state = 209
                self.match(llullParser.PARR)
                pass
            elif token in [llullParser.NUM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 211
                self.match(llullParser.NUM)
                pass
            elif token in [llullParser.STRING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 212
                self.match(llullParser.STRING)
                pass
            elif token in [llullParser.ID]:
                self.enterOuterAlt(localctx, 4)
                self.state = 213
                self.match(llullParser.ID)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[18] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         




